e.exports = function (e, t) { var r = e.Assertion, n = e.AssertionError, a = t.flag; function o(e, r) { r && a(this, "message", r), e = e.toLowerCase(); var n = a(this, "object"), o = ~["a", "e", "i", "o", "u"].indexOf(e.charAt(0)) ? "an " : "a "; this.assert(e === t.type(n).toLowerCase(), "expected #{this} to be " + o + e, "expected #{this} not to be " + o + e) } function i(e, r) { return t.isNaN(e) && t.isNaN(r) || e === r } function s() { a(this, "contains", !0) } function u(e, o) { o && a(this, "message", o); var s = a(this, "object"), u = t.type(s).toLowerCase(), l = a(this, "message"), c = a(this, "negate"), h = a(this, "ssfi"), f = a(this, "deep"), p = f ? "deep " : ""; l = l ? l + ": " : ""; var d = !1; switch (u) { case "string": d = -1 !== s.indexOf(e); break; case "weakset": if (f) throw new n(l + "unable to use .deep.include with WeakSet", void 0, h); d = s.has(e); break; case "map": var g = f ? t.eql : i; s.forEach((function (t) { d = d || g(t, e) })); break; case "set": f ? s.forEach((function (r) { d = d || t.eql(r, e) })) : d = s.has(e); break; case "array": d = f ? s.some((function (r) { return t.eql(r, e) })) : -1 !== s.indexOf(e); break; default: if (e !== Object(e)) throw new n(l + "object tested must be an array, a map, an object, a set, a string, or a weakset, but " + u + " given", void 0, h); var m = Object.keys(e), y = null, b = 0; if (m.forEach((function (o) { var i = new r(s); if (t.transferFlags(this, i, !0), a(i, "lockSsfi", !0), c && 1 !== m.length) try { i.property(o, e[o]) } catch (e) { if (!t.checkError.compatibleConstructor(e, n)) throw e; null === y && (y = e), b++ } else i.property(o, e[o]) }), this), c && m.length > 1 && b === m.length) throw y; return }this.assert(d, "expected #{this} to " + p + "include " + t.inspect(e), "expected #{this} to not " + p + "include " + t.inspect(e)) } function l() { var e = a(this, "object"), r = t.type(e); this.assert("Arguments" === r, "expected #{this} to be arguments but got " + r, "expected #{this} to not be arguments") } function c(e, t) { t && a(this, "message", t); var r = a(this, "object"); if (a(this, "deep")) { var n = a(this, "lockSsfi"); a(this, "lockSsfi", !0), this.eql(e), a(this, "lockSsfi", n) } else this.assert(e === r, "expected #{this} to equal #{exp}", "expected #{this} to not equal #{exp}", e, this._obj, !0) } function h(e, r) { r && a(this, "message", r), this.assert(t.eql(e, a(this, "object")), "expected #{this} to deeply equal #{exp}", "expected #{this} to not deeply equal #{exp}", e, this._obj, !0) } function f(e, o) { o && a(this, "message", o); var i, s = a(this, "object"), u = a(this, "doLength"), l = a(this, "message"), c = l ? l + ": " : "", h = a(this, "ssfi"), f = t.type(s).toLowerCase(), p = t.type(e).toLowerCase(), d = !0; if (u && "map" !== f && "set" !== f && new r(s, l, h, !0).to.have.property("length"), u || "date" !== f || "date" === p) if ("number" === p || !u && "number" !== f) if (u || "date" === f || "number" === f) d = !1; else { i = c + "expected " + ("string" === f ? "'" + s + "'" : s) + " to be a number or a date" } else i = c + "the argument to above must be a number"; else i = c + "the argument to above must be a date"; if (d) throw new n(i, void 0, h); if (u) { var g, m = "length"; "map" === f || "set" === f ? (m = "size", g = s.size) : g = s.length, this.assert(g > e, "expected #{this} to have a " + m + " above #{exp} but got #{act}", "expected #{this} to not have a " + m + " above #{exp}", e, g) } else this.assert(s > e, "expected #{this} to be above #{exp}", "expected #{this} to be at most #{exp}", e) } function p(e, o) { o && a(this, "message", o); var i, s = a(this, "object"), u = a(this, "doLength"), l = a(this, "message"), c = l ? l + ": " : "", h = a(this, "ssfi"), f = t.type(s).toLowerCase(), p = t.type(e).toLowerCase(), d = !0; if (u && "map" !== f && "set" !== f && new r(s, l, h, !0).to.have.property("length"), u || "date" !== f || "date" === p) if ("number" === p || !u && "number" !== f) if (u || "date" === f || "number" === f) d = !1; else { i = c + "expected " + ("string" === f ? "'" + s + "'" : s) + " to be a number or a date" } else i = c + "the argument to least must be a number"; else i = c + "the argument to least must be a date"; if (d) throw new n(i, void 0, h); if (u) { var g, m = "length"; "map" === f || "set" === f ? (m = "size", g = s.size) : g = s.length, this.assert(g >= e, "expected #{this} to have a " + m + " at least #{exp} but got #{act}", "expected #{this} to have a " + m + " below #{exp}", e, g) } else this.assert(s >= e, "expected #{this} to be at least #{exp}", "expected #{this} to be below #{exp}", e) } function d(e, o) { o && a(this, "message", o); var i, s = a(this, "object"), u = a(this, "doLength"), l = a(this, "message"), c = l ? l + ": " : "", h = a(this, "ssfi"), f = t.type(s).toLowerCase(), p = t.type(e).toLowerCase(), d = !0; if (u && "map" !== f && "set" !== f && new r(s, l, h, !0).to.have.property("length"), u || "date" !== f || "date" === p) if ("number" === p || !u && "number" !== f) if (u || "date" === f || "number" === f) d = !1; else { i = c + "expected " + ("string" === f ? "'" + s + "'" : s) + " to be a number or a date" } else i = c + "the argument to below must be a number"; else i = c + "the argument to below must be a date"; if (d) throw new n(i, void 0, h); if (u) { var g, m = "length"; "map" === f || "set" === f ? (m = "size", g = s.size) : g = s.length, this.assert(g < e, "expected #{this} to have a " + m + " below #{exp} but got #{act}", "expected #{this} to not have a " + m + " below #{exp}", e, g) } else this.assert(s < e, "expected #{this} to be below #{exp}", "expected #{this} to be at least #{exp}", e) } function g(e, o) { o && a(this, "message", o); var i, s = a(this, "object"), u = a(this, "doLength"), l = a(this, "message"), c = l ? l + ": " : "", h = a(this, "ssfi"), f = t.type(s).toLowerCase(), p = t.type(e).toLowerCase(), d = !0; if (u && "map" !== f && "set" !== f && new r(s, l, h, !0).to.have.property("length"), u || "date" !== f || "date" === p) if ("number" === p || !u && "number" !== f) if (u || "date" === f || "number" === f) d = !1; else { i = c + "expected " + ("string" === f ? "'" + s + "'" : s) + " to be a number or a date" } else i = c + "the argument to most must be a number"; else i = c + "the argument to most must be a date"; if (d) throw new n(i, void 0, h); if (u) { var g, m = "length"; "map" === f || "set" === f ? (m = "size", g = s.size) : g = s.length, this.assert(g <= e, "expected #{this} to have a " + m + " at most #{exp} but got #{act}", "expected #{this} to have a " + m + " above #{exp}", e, g) } else this.assert(s <= e, "expected #{this} to be at most #{exp}", "expected #{this} to be above #{exp}", e) } function m(e, r) { r && a(this, "message", r); var o = a(this, "object"), i = a(this, "ssfi"), s = a(this, "message"); try { var u = o instanceof e } catch (r) { if (r instanceof TypeError) throw new n((s = s ? s + ": " : "") + "The instanceof assertion needs a constructor but " + t.type(e) + " was given.", void 0, i); throw r } var l = t.getName(e); null === l && (l = "an unnamed constructor"), this.assert(u, "expected #{this} to be an instance of " + l, "expected #{this} to not be an instance of " + l) } function y(e, r, o) { o && a(this, "message", o); var i = a(this, "nested"), s = a(this, "own"), u = a(this, "message"), l = a(this, "object"), c = a(this, "ssfi"), h = typeof e; if (u = u ? u + ": " : "", i) { if ("string" !== h) throw new n(u + "the argument to property must be a string when using nested syntax", void 0, c) } else if ("string" !== h && "number" !== h && "symbol" !== h) throw new n(u + "the argument to property must be a string, number, or symbol", void 0, c); if (i && s) throw new n(u + 'The "nested" and "own" flags cannot be combined.', void 0, c); if (null == l) throw new n(u + "Target cannot be null or undefined.", void 0, c); var f, p = a(this, "deep"), d = a(this, "negate"), g = i ? t.getPathInfo(l, e) : null, m = i ? g.value : l[e], y = ""; p && (y += "deep "), s && (y += "own "), i && (y += "nested "), y += "property ", f = s ? Object.prototype.hasOwnProperty.call(l, e) : i ? g.exists : t.hasProperty(l, e), d && 1 !== arguments.length || this.assert(f, "expected #{this} to have " + y + t.inspect(e), "expected #{this} to not have " + y + t.inspect(e)), arguments.length > 1 && this.assert(f && (p ? t.eql(r, m) : r === m), "expected #{this} to have " + y + t.inspect(e) + " of #{exp}, but got #{act}", "expected #{this} to not have " + y + t.inspect(e) + " of #{act}", r, m), a(this, "object", m) } function b(e, t, r) { a(this, "own", !0), y.apply(this, arguments) } function v(e, r, n) { "string" == typeof r && (n = r, r = null), n && a(this, "message", n); var o = a(this, "object"), i = Object.getOwnPropertyDescriptor(Object(o), e); i && r ? this.assert(t.eql(r, i), "expected the own property descriptor for " + t.inspect(e) + " on #{this} to match " + t.inspect(r) + ", got " + t.inspect(i), "expected the own property descriptor for " + t.inspect(e) + " on #{this} to not match " + t.inspect(r), r, i, !0) : this.assert(i, "expected #{this} to have an own property descriptor for " + t.inspect(e), "expected #{this} to not have an own property descriptor for " + t.inspect(e)), a(this, "object", i) } function C() { a(this, "doLength", !0) } function _(e, n) { n && a(this, "message", n); var o, i = a(this, "object"), s = t.type(i).toLowerCase(), u = a(this, "message"), l = a(this, "ssfi"), c = "length"; switch (s) { case "map": case "set": c = "size", o = i.size; break; default: new r(i, u, l, !0).to.have.property("length"), o = i.length }this.assert(o == e, "expected #{this} to have a " + c + " of #{exp} but got #{act}", "expected #{this} to not have a " + c + " of #{act}", e, o) } function O(e, t) { t && a(this, "message", t); var r = a(this, "object"); this.assert(e.exec(r), "expected #{this} to match " + e, "expected #{this} not to match " + e) } function w(e) { var r, o, i = a(this, "object"), s = t.type(i), u = t.type(e), l = a(this, "ssfi"), c = a(this, "deep"), h = "", f = !0, p = a(this, "message"), d = (p = p ? p + ": " : "") + "when testing keys against an object or an array you must give a single Array|Object|String argument or multiple String arguments"; if ("Map" === s || "Set" === s) h = c ? "deeply " : "", o = [], i.forEach((function (e, t) { o.push(t) })), "Array" !== u && (e = Array.prototype.slice.call(arguments)); else { switch (o = t.getOwnEnumerableProperties(i), u) { case "Array": if (arguments.length > 1) throw new n(d, void 0, l); break; case "Object": if (arguments.length > 1) throw new n(d, void 0, l); e = Object.keys(e); break; default: e = Array.prototype.slice.call(arguments) }e = e.map((function (e) { return "symbol" == typeof e ? e : String(e) })) } if (!e.length) throw new n(p + "keys required", void 0, l); var g = e.length, m = a(this, "any"), y = a(this, "all"), b = e; if (m || y || (y = !0), m && (f = b.some((function (e) { return o.some((function (r) { return c ? t.eql(e, r) : e === r })) }))), y && (f = b.every((function (e) { return o.some((function (r) { return c ? t.eql(e, r) : e === r })) })), a(this, "contains") || (f = f && e.length == o.length)), g > 1) { var v = (e = e.map((function (e) { return t.inspect(e) }))).pop(); y && (r = e.join(", ") + ", and " + v), m && (r = e.join(", ") + ", or " + v) } else r = t.inspect(e[0]); r = (g > 1 ? "keys " : "key ") + r, r = (a(this, "contains") ? "contain " : "have ") + r, this.assert(f, "expected #{this} to " + h + r, "expected #{this} to not " + h + r, b.slice(0).sort(t.compareByInspect), o.sort(t.compareByInspect), !0) } function H(e, n, o) { o && a(this, "message", o); var i, s = a(this, "object"), u = a(this, "ssfi"), l = a(this, "message"), c = a(this, "negate") || !1; new r(s, l, u, !0).is.a("function"), (e instanceof RegExp || "string" == typeof e) && (n = e, e = null); try { s() } catch (e) { i = e } var h = void 0 === e && void 0 === n, f = Boolean(e && n), p = !1, d = !1; if (h || !h && !c) { var g = "an error"; e instanceof Error ? g = "#{exp}" : e && (g = t.checkError.getConstructorName(e)), this.assert(i, "expected #{this} to throw " + g, "expected #{this} to not throw an error but #{act} was thrown", e && e.toString(), i instanceof Error ? i.toString() : "string" == typeof i ? i : i && t.checkError.getConstructorName(i)) } if (e && i) { if (e instanceof Error) t.checkError.compatibleInstance(i, e) === c && (f && c ? p = !0 : this.assert(c, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (i && !c ? " but #{act} was thrown" : ""), e.toString(), i.toString())); t.checkError.compatibleConstructor(i, e) === c && (f && c ? p = !0 : this.assert(c, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (i ? " but #{act} was thrown" : ""), e instanceof Error ? e.toString() : e && t.checkError.getConstructorName(e), i instanceof Error ? i.toString() : i && t.checkError.getConstructorName(i))) } if (i && null != n) { var m = "including"; n instanceof RegExp && (m = "matching"), t.checkError.compatibleMessage(i, n) === c && (f && c ? d = !0 : this.assert(c, "expected #{this} to throw error " + m + " #{exp} but got #{act}", "expected #{this} to throw error not " + m + " #{exp}", n, t.checkError.getMessage(i))) } p && d && this.assert(c, "expected #{this} to throw #{exp} but #{act} was thrown", "expected #{this} to not throw #{exp}" + (i ? " but #{act} was thrown" : ""), e instanceof Error ? e.toString() : e && t.checkError.getConstructorName(e), i instanceof Error ? i.toString() : i && t.checkError.getConstructorName(i)), a(this, "object", i) } function A(e, r) { r && a(this, "message", r); var n = a(this, "object"), o = a(this, "itself"), i = "function" != typeof n || o ? n[e] : n.prototype[e]; this.assert("function" == typeof i, "expected #{this} to respond to " + t.inspect(e), "expected #{this} to not respond to " + t.inspect(e)) } function E(e, r) { r && a(this, "message", r); var n = e(a(this, "object")); this.assert(n, "expected #{this} to satisfy " + t.objDisplay(e), "expected #{this} to not satisfy" + t.objDisplay(e), !a(this, "negate"), n) } function x(e, t, o) { o && a(this, "message", o); var i = a(this, "object"), s = a(this, "message"), u = a(this, "ssfi"); if (new r(i, s, u, !0).is.a("number"), "number" != typeof e || "number" != typeof t) throw new n((s = s ? s + ": " : "") + "the arguments to closeTo or approximately must be numbers", void 0, u); this.assert(Math.abs(i - e) <= t, "expected #{this} to be close to " + e + " +/- " + t, "expected #{this} not to be close to " + e + " +/- " + t) } function D(e, t, n) { n && a(this, "message", n); var o, i = a(this, "object"), s = a(this, "message"), u = a(this, "ssfi"); new r(i, s, u, !0).is.a("function"), t ? (new r(e, s, u, !0).to.have.property(t), o = e[t]) : (new r(e, s, u, !0).is.a("function"), o = e()), i(); var l = null == t ? e() : e[t], c = null == t ? o : "." + t; a(this, "deltaMsgObj", c), a(this, "initialDeltaValue", o), a(this, "finalDeltaValue", l), a(this, "deltaBehavior", "change"), a(this, "realDelta", l !== o), this.assert(o !== l, "expected " + c + " to change", "expected " + c + " to not change") } function T(e, t, n) { n && a(this, "message", n); var o, i = a(this, "object"), s = a(this, "message"), u = a(this, "ssfi"); new r(i, s, u, !0).is.a("function"), t ? (new r(e, s, u, !0).to.have.property(t), o = e[t]) : (new r(e, s, u, !0).is.a("function"), o = e()), new r(o, s, u, !0).is.a("number"), i(); var l = null == t ? e() : e[t], c = null == t ? o : "." + t; a(this, "deltaMsgObj", c), a(this, "initialDeltaValue", o), a(this, "finalDeltaValue", l), a(this, "deltaBehavior", "increase"), a(this, "realDelta", l - o), this.assert(l - o > 0, "expected " + c + " to increase", "expected " + c + " to not increase") } function S(e, t, n) { n && a(this, "message", n); var o, i = a(this, "object"), s = a(this, "message"), u = a(this, "ssfi"); new r(i, s, u, !0).is.a("function"), t ? (new r(e, s, u, !0).to.have.property(t), o = e[t]) : (new r(e, s, u, !0).is.a("function"), o = e()), new r(o, s, u, !0).is.a("number"), i(); var l = null == t ? e() : e[t], c = null == t ? o : "." + t; a(this, "deltaMsgObj", c), a(this, "initialDeltaValue", o), a(this, "finalDeltaValue", l), a(this, "deltaBehavior", "decrease"), a(this, "realDelta", o - l), this.assert(l - o < 0, "expected " + c + " to decrease", "expected " + c + " to not decrease") } ["to", "be", "been", "is", "and", "has", "have", "with", "that", "which", "at", "of", "same", "but", "does", "still"].forEach((function (e) { r.addProperty(e) })), r.addProperty("not", (function () { a(this, "negate", !0) })), r.addProperty("deep", (function () { a(this, "deep", !0) })), r.addProperty("nested", (function () { a(this, "nested", !0) })), r.addProperty("own", (function () { a(this, "own", !0) })), r.addProperty("ordered", (function () { a(this, "ordered", !0) })), r.addProperty("any", (function () { a(this, "any", !0), a(this, "all", !1) })), r.addProperty("all", (function () { a(this, "all", !0), a(this, "any", !1) })), r.addChainableMethod("an", o), r.addChainableMethod("a", o), r.addChainableMethod("include", u, s), r.addChainableMethod("contain", u, s), r.addChainableMethod("contains", u, s), r.addChainableMethod("includes", u, s), r.addProperty("ok", (function () { this.assert(a(this, "object"), "expected #{this} to be truthy", "expected #{this} to be falsy") })), r.addProperty("true", (function () { this.assert(!0 === a(this, "object"), "expected #{this} to be true", "expected #{this} to be false", !a(this, "negate")) })), r.addProperty("false", (function () { this.assert(!1 === a(this, "object"), "expected #{this} to be false", "expected #{this} to be true", !!a(this, "negate")) })), r.addProperty("null", (function () { this.assert(null === a(this, "object"), "expected #{this} to be null", "expected #{this} not to be null") })), r.addProperty("undefined", (function () { this.assert(void 0 === a(this, "object"), "expected #{this} to be undefined", "expected #{this} not to be undefined") })), r.addProperty("NaN", (function () { this.assert(t.isNaN(a(this, "object")), "expected #{this} to be NaN", "expected #{this} not to be NaN") })), r.addProperty("exist", (function () { var e = a(this, "object"); this.assert(null != e, "expected #{this} to exist", "expected #{this} to not exist") })), r.addProperty("empty", (function () { var e, r = a(this, "object"), o = a(this, "ssfi"), i = a(this, "message"); switch (i = i ? i + ": " : "", t.type(r).toLowerCase()) { case "array": case "string": e = r.length; break; case "map": case "set": e = r.size; break; case "weakmap": case "weakset": throw new n(i + ".empty was passed a weak collection", void 0, o); case "function": var s = i + ".empty was passed a function " + t.getName(r); throw new n(s.trim(), void 0, o); default: if (r !== Object(r)) throw new n(i + ".empty was passed non-string primitive " + t.inspect(r), void 0, o); e = Object.keys(r).length }this.assert(0 === e, "expected #{this} to be empty", "expected #{this} not to be empty") })), r.addProperty("arguments", l), r.addProperty("Arguments", l), r.addMethod("equal", c), r.addMethod("equals", c), r.addMethod("eq", c), r.addMethod("eql", h), r.addMethod("eqls", h), r.addMethod("above", f), r.addMethod("gt", f), r.addMethod("greaterThan", f), r.addMethod("least", p), r.addMethod("gte", p), r.addMethod("below", d), r.addMethod("lt", d), r.addMethod("lessThan", d), r.addMethod("most", g), r.addMethod("lte", g), r.addMethod("within", (function (e, o, i) { i && a(this, "message", i); var s, u = a(this, "object"), l = a(this, "doLength"), c = a(this, "message"), h = c ? c + ": " : "", f = a(this, "ssfi"), p = t.type(u).toLowerCase(), d = t.type(e).toLowerCase(), g = t.type(o).toLowerCase(), m = !0, y = "date" === d && "date" === g ? e.toUTCString() + ".." + o.toUTCString() : e + ".." + o; if (l && "map" !== p && "set" !== p && new r(u, c, f, !0).to.have.property("length"), l || "date" !== p || "date" === d && "date" === g) if ("number" === d && "number" === g || !l && "number" !== p) if (l || "date" === p || "number" === p) m = !1; else { s = h + "expected " + ("string" === p ? "'" + u + "'" : u) + " to be a number or a date" } else s = h + "the arguments to within must be numbers"; else s = h + "the arguments to within must be dates"; if (m) throw new n(s, void 0, f); if (l) { var b, v = "length"; "map" === p || "set" === p ? (v = "size", b = u.size) : b = u.length, this.assert(b >= e && b <= o, "expected #{this} to have a " + v + " within " + y, "expected #{this} to not have a " + v + " within " + y) } else this.assert(u >= e && u <= o, "expected #{this} to be within " + y, "expected #{this} to not be within " + y) })), r.addMethod("instanceof", m), r.addMethod("instanceOf", m), r.addMethod("property", y), r.addMethod("ownProperty", b), r.addMethod("haveOwnProperty", b), r.addMethod("ownPropertyDescriptor", v), r.addMethod("haveOwnPropertyDescriptor", v), r.addChainableMethod("length", _, C), r.addChainableMethod("lengthOf", _, C), r.addMethod("match", O), r.addMethod("matches", O), r.addMethod("string", (function (e, n) { n && a(this, "message", n); var o = a(this, "object"), i = a(this, "message"), s = a(this, "ssfi"); new r(o, i, s, !0).is.a("string"), this.assert(~o.indexOf(e), "expected #{this} to contain " + t.inspect(e), "expected #{this} to not contain " + t.inspect(e)) })), r.addMethod("keys", w), r.addMethod("key", w), r.addMethod("throw", H), r.addMethod("throws", H), r.addMethod("Throw", H), r.addMethod("respondTo", A), r.addMethod("respondsTo", A), r.addProperty("itself", (function () { a(this, "itself", !0) })), r.addMethod("satisfy", E), r.addMethod("satisfies", E), r.addMethod("closeTo", x), r.addMethod("approximately", x), r.addMethod("members", (function (e, n) { n && a(this, "message", n); var o = a(this, "object"), i = a(this, "message"), s = a(this, "ssfi"); new r(o, i, s, !0).to.be.an("array"), new r(e, i, s, !0).to.be.an("array"); var u, l, c, h = a(this, "contains"), f = a(this, "ordered"); h ? (l = "expected #{this} to be " + (u = f ? "an ordered superset" : "a superset") + " of #{exp}", c = "expected #{this} to not be " + u + " of #{exp}") : (l = "expected #{this} to have the same " + (u = f ? "ordered members" : "members") + " as #{exp}", c = "expected #{this} to not have the same " + u + " as #{exp}"); var p = a(this, "deep") ? t.eql : void 0; this.assert(function (e, t, r, n, a) { if (!n) { if (e.length !== t.length) return !1; t = t.slice() } return e.every((function (e, o) { if (a) return r ? r(e, t[o]) : e === t[o]; if (!r) { var i = t.indexOf(e); return -1 !== i && (n || t.splice(i, 1), !0) } return t.some((function (a, o) { return !!r(e, a) && (n || t.splice(o, 1), !0) })) })) }(e, o, p, h, f), l, c, e, o, !0) })), r.addMethod("oneOf", (function (e, t) { t && a(this, "message", t); var n = a(this, "object"), o = a(this, "message"), i = a(this, "ssfi"); new r(e, o, i, !0).to.be.an("array"), this.assert(e.indexOf(n) > -1, "expected #{this} to be one of #{exp}", "expected #{this} to not be one of #{exp}", e, n) })), r.addMethod("change", D), r.addMethod("changes", D), r.addMethod("increase", T), r.addMethod("increases", T), r.addMethod("decrease", S), r.addMethod("decreases", S), r.addMethod("by", (function (e, t) { t && a(this, "message", t); var r, n = a(this, "deltaMsgObj"), o = a(this, "initialDeltaValue"), i = a(this, "finalDeltaValue"), s = a(this, "deltaBehavior"), u = a(this, "realDelta"); r = "change" === s ? Math.abs(i - o) === Math.abs(e) : u === Math.abs(e), this.assert(r, "expected " + n + " to " + s + " by " + e, "expected " + n + " to not " + s + " by " + e) })), r.addProperty("extensible", (function () { var e = a(this, "object"), t = e === Object(e) && Object.isExtensible(e); this.assert(t, "expected #{this} to be extensible", "expected #{this} to not be extensible") })), r.addProperty("sealed", (function () { var e = a(this, "object"), t = e !== Object(e) || Object.isSealed(e); this.assert(t, "expected #{this} to be sealed", "expected #{this} to not be sealed") })), r.addProperty("frozen", (function () { var e = a(this, "object"), t = e !== Object(e) || Object.isFrozen(e); this.assert(t, "expected #{this} to be frozen", "expected #{this} to not be frozen") })), r.addProperty("finite", (function (e) { var t = a(this, "object"); this.assert("number" == typeof t && isFinite(t), "expected #{this} to be a finite number", "expected #{this} to not be a finite number") })) }}
